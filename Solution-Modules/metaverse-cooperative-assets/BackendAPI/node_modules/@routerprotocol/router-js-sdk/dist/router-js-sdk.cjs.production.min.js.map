{"version":3,"file":"router-js-sdk.cjs.production.min.js","sources":["../src/constants/network/index.ts","../src/types/index.ts","../src/constants/tokens/index.ts","../src/constants/index.ts","../src/utils/index.ts","../src/router-protocol/index.ts","../src/functions/getSwapQuote.ts","../src/functions/getApproval.ts","../src/functions/getFee.ts","../src/functions/getTxStatus.ts"],"sourcesContent":["import networks from './network.mainnet.json'\n\nexport interface NetworkType {\n    name: string;\n    type: string;\n    networkId: string;\n    id: string;\n    endpoint: string;\n    socket: string;\n    from: string;\n    stakingRewardsFactory: string;\n    native: string;\n    wnative: string;\n    rewardsToken: string;\n    feeHandler: string;\n    http: string;\n    bridge: string;\n    erc20Handler: string;\n    reserveHandler: string;\n    oneSplit: string;\n    genericHandler: string;\n    gasLimit: string;\n    maxGasPrice: string;\n}\n\nconst config_generator = () => {\n    let network_config: { [chainId: string]: NetworkType } = {}\n    networks.forEach(network => {\n        network_config = { ...network_config, [network.networkId]: network }\n        return\n    })\n    return network_config\n}\n\nexport const NETWORK_CONFIG: { [chainId: string]: NetworkType } = config_generator()","export enum ChainId {\n    MAINNET = \"1\",\n    ROPSTEN = \"3\",\n    RINKEBY = \"4\",\n    GÃ–RLI = \"5\",\n    KOVAN = \"42\",\n    POLYGON = \"137\",\n    MUMBAI = \"80001\",\n    OKEX = \"66\",\n    ARBITRUM = \"42161\",\n    FANTOM = \"250\",\n    OPTIMISM = \"10\",\n    XDAI = \"100\",\n    BSC = \"56\",\n    HARMONY = \"1666600000\",\n    AVALANCHE = \"43114\",\n    FUJI = \"43113\"\n}\nexport interface AssetType {\n    name: string;\n    symbol: string;\n    decimals: string;\n    address: string;\n    chainId: string;\n    logoURI: string;\n    lpSymbol: string;\n    lpAddress: string;\n    stakingRewards: string;\n    resourceId: string;\n    lpResourceId: string;\n    mappedOnBridge: boolean;\n    native: boolean;\n    hasLpToken: boolean;\n    isLpToken: boolean;\n    stableAsset: boolean;\n    mining: boolean;\n    activeMining: boolean;\n    enableLiquidityMining: boolean;\n  }\nexport interface TransactionStatus{\"tx_status\":string,\n\"tx_status_code\":number,\n\"src_chain_id\":string,\n\"dest_chain_id\":string,\n\"src_tx_hash\":string,\n\"dest_tx_hash\":string}\nexport * from \"./quote\"","import ropstenAsset from './ropstenTestnet.ethereum.json'\nimport kovanAsset from './kovanTestnet.ethereum.json'\nimport maticAsset from './maticTestnet.ethereum.json'\nimport bscAsset from './bsc.mainnet.json'\nimport avaxFujiAsset from './avax.testnet.json'\nimport avaxAsset from './avax.mainnet.json'\nimport okexAsset from './okex.testnet.json'\nimport ethereumAsset from './ethereum.mainnet.json'\nimport polgonAsset from './polygon.mainnet.json'\nimport ftmAsset from './ftm.mainnet.json'\nimport arbitrumAsset from './arbitrum.mainnet.json'\nimport optimismAsset from './optimism.mainnet.json'\nimport { AssetType, ChainId } from '../../types'\n\n export const ASSET_LIST:{[chainId:string]:AssetType[]} = {\n    [ChainId.KOVAN]: kovanAsset,\n    [ChainId.MUMBAI]: maticAsset,\n    [ChainId.BSC]: bscAsset,\n    [ChainId.AVALANCHE]: avaxAsset,\n    [ChainId.FUJI]: avaxFujiAsset,\n    [ChainId.MAINNET]: ethereumAsset,\n    [ChainId.POLYGON]: polgonAsset,\n    [ChainId.FANTOM]: ftmAsset,\n    [ChainId.ARBITRUM]: arbitrumAsset,\n    [ChainId.OPTIMISM]: optimismAsset,\n    [ChainId.ROPSTEN]: ropstenAsset,\n    [ChainId.OKEX]: okexAsset,\n  }","\nexport * from './network'\nexport * from './tokens'\n\nexport const ROUTER_STATS_HOST=\"https://api.stats.routerprotocol.com\"\nexport const NETWORK_CONFIG_URL=\"https://raw.githubusercontent.com/router-protocol/sdk-network-config/main/networkConfig/mainnet.json\"","import { AssetType, NETWORK_CONFIG } from \"..\"\n\nexport const isNative=(asset:AssetType)=>{\n    return !!asset.native\n}\nexport const isAddressNative=(address:string,chainId:string)=>{\n    return NETWORK_CONFIG[chainId].native===address ;\n}\nexport const isReserveAsset=(asset:AssetType)=>{\n    return !(asset.resourceId===\"\")\n}","import { Signer } from \"@ethersproject/abstract-signer\";\nimport {  Provider as ProviderType, TransactionResponse } from \"@ethersproject/providers\";\nimport getSwapQuote from \"../functions/getSwapQuote\";\nimport { NetworkType, NETWORK_CONFIG_URL, Quote } from \"../index\";\nimport { ethers } from \"ethers\";\nimport axios from \"axios\";\nimport { getFeeTokenApproval, getSourceTokenApproval, setFeeTokenApproval, setSourceTokenApproval } from \"../functions/getApproval\";\nimport { getFeeAmount } from \"../functions/getFee\";\nimport { getTxStatus } from \"../functions/getTxStatus\";\n\nexport class RouterProtocol {\n  public readonly apiKey: string\n  public readonly sourceNetworkId: string\n  public readonly provider: ProviderType\n  private networkConfig: ({ [chainId: string]: NetworkType }|undefined);\n\n  constructor (apiKey:string,sourceNetworkId:string,provider:ProviderType) {\n      this.apiKey = apiKey;\n      this.provider = provider;\n      this.sourceNetworkId = sourceNetworkId;\n  }\n\n  public async initialize(){\n    try{\n     const networks:NetworkType[]=await axios.get(NETWORK_CONFIG_URL).then((res)=>{\n       return res.data\n     })\n     let network_config: { [chainId: string]: NetworkType } = {}\n    networks.forEach(network => {\n        network_config = { ...network_config, [network.networkId]: network }\n        return\n    })\n     this.networkConfig=network_config;\n    } catch(err){\n      throw err\n    }\n  }\n  // to-be deprecated\n  public async initailize(){\n    try{\n     const networks:NetworkType[]=await axios.get(NETWORK_CONFIG_URL).then((res)=>{\n       return res.data\n     })\n     let network_config: { [chainId: string]: NetworkType } = {}\n    networks.forEach(network => {\n        network_config = { ...network_config, [network.networkId]: network }\n        return\n    })\n     this.networkConfig=network_config;\n    } catch(err){\n      throw err\n    }\n  }\n  /**\n   * gets quote\n   */\n\n  public async getQuote(\n    amount:string,\n    destinationNetworkId:string,\n    sourceTokenAddress:string,\n    destinationTokenAddress:string,\n    userAddress:string,\n    feeTokenAddress:string,\n    slippageTolerance:number\n    ):Promise<Quote>{\n      try {\n        if(!this.networkConfig)\n        throw \"Not initialized!\"\n        const res=await getSwapQuote({\n          expandedAmount:amount,\n          sourceNetworkId:this.sourceNetworkId,\n          destinationNetworkId,\n          sourceTokenAddress,\n          destinationTokenAddress,\n          userAddress,\n          feeTokenAddress,\n          slippageTolerance,\n          network_config:this.networkConfig,\n          widgetId:this.apiKey\n        })\n      return res\n    } catch(err){\n      throw err;\n    }\n  }\n  /**\n   * swaps\n   */\n  public async swap(quote:Quote,signer:Signer,txGasLimit?:string) {\ntry{\n  if(!this.networkConfig)\n  throw \"Not initialized!\"\n  if(!quote)\n  throw \"No Quote\"\n    // setting the gas price and limit\n    const gasPrice = await this.provider.getGasPrice()\n    \n    const gasLimit = ethers.utils.hexlify(Number(txGasLimit?txGasLimit:1000000))\n\n    const transaction:TransactionResponse=await signer.sendTransaction({...quote.txn.execution,gasPrice,gasLimit});\n    await transaction.wait()\n    return transaction;}\n    catch(err){\n      throw err;\n    }\n  }\n  public async getSourceTokenAllowance(tokenAddress: string,\n    destinationNetworkId: string,\n    userAddress: string,\n    ){\n    try{\n      if(!this.networkConfig)\n      throw \"Not initialized!\"\n      return await getSourceTokenApproval({\n      tokenAddress,\n      sourceNetworkId:this.sourceNetworkId,\n      provider:this.provider,\n      destinationNetworkId,\n      userAddress,\n      network_config:this.networkConfig\n    })}catch(err){\n      throw err;\n    }\n    }\n  public async getFeeTokenAllowance(tokenAddress: string,\n    destinationNetworkId: string,\n    userAddress: string,\n    ){\n    try{\n      if(!this.networkConfig)\n      throw \"Not initialized!\"\n      return await getFeeTokenApproval({\n      tokenAddress,\n      networkId:destinationNetworkId,\n      provider:this.provider,\n      userAddress,\n            network_config:this.networkConfig\n\n    })}catch(err){\n      throw err;\n    }\n    }\n\n  public async approveSourceToken(tokenAddress: string,\n    userAddress: string,\n    amount: string,\n    destinationNetworkId: string,\n    signer:Signer,\n    txGasLimit?:number){\n    try{\n      if(!this.networkConfig)\n      throw \"Not initialized!\"\n      const transactionReq= await setSourceTokenApproval({\n      tokenAddress,\n      amount,\n      destinationNetworkId,\n      userAddress,\n      sourceNetworkId:this.sourceNetworkId,\n            network_config:this.networkConfig\n\n    })\n    // setting the gas price and limit\n    const gasPrice = await this.provider.getGasPrice()\n\n    const gasLimit = ethers.utils.hexlify(Number(txGasLimit?txGasLimit:1000000))\n    const transaction:TransactionResponse=await signer.sendTransaction({...transactionReq,gasPrice,gasLimit});\n    await transaction.wait()\n    return transaction;}catch(err){\n      throw err;\n    }\n  }\n  public async approveFeeToken(tokenAddress: string,\n    userAddress: string,\n    amount: string,signer:Signer,\n    txGasLimit?:number){\n  try {\n    if(!this.networkConfig)\n    throw \"Not initialized!\"\n    const transactionReq= await setFeeTokenApproval({\n     tokenAddress,\n     amount,\n     userAddress,\n     sourceNetworkId:this.sourceNetworkId,\n           network_config:this.networkConfig\n\n   })\n   // setting the gas price and limit\n   const gasPrice = await this.provider.getGasPrice()\n\n   const gasLimit = ethers.utils.hexlify(Number(txGasLimit?txGasLimit:1000000))\n   const transaction:TransactionResponse=await signer.sendTransaction({...transactionReq,gasPrice,gasLimit});\n   await transaction.wait()\n   return transaction;} catch(err){\n    throw err;\n  }\n  }\n  public async getBridgeFee(\n    destinationNetworkId: string,\n  ){\n    try{\n      if(!this.networkConfig)\n      throw \"Not initialized!\"\n      const fee = await getFeeAmount({\n      sourceNetworkId:this.sourceNetworkId,\n      destNetworkId:destinationNetworkId,\n      sourceProvider:this.provider,\n            network_config:this.networkConfig\n})\n    return fee} catch(err){\n      throw err;\n    }\n  }\n  public async getTransactionStatus(txHash:string){\n    try{\n      if(!this.networkConfig)\n      throw \"Not initialized!\"\n      const res=await getTxStatus(txHash,this.sourceNetworkId)\n    return res} catch(err){\n      throw err;\n    }\n  }\n}\n\n\n// whole test\n// feeTokenName\n// transaction status in midway\n// transaction status endpoint","import axios from 'axios'\nimport { isAddressNative } from '../utils'\nimport { NetworkType } from '..'\n// const PATH_FINDER_ENDPOINT = 'https://api.pathfinder.routerprotocol.com/api/getRouteForMultiSwap'\nconst PATH_FINDER_API_URL = \"https://api.pathfinder.routerprotocol.com/api\"\n\n\n// calling the pathfinder api using axios\nconst fetchPathfinderData = async (params: any) => {\n    const endpoint = \"quote\"\n    const pathUrl = `${PATH_FINDER_API_URL}/${endpoint}`\n    try {\n        const res = await axios.get(pathUrl, { params })\n        return res.data\n    } catch (e) {\n        console.error(`Fetching data from pathfinder: ${e}`)\n    }\n}\nconst getSwapQuote = async ({ \n     expandedAmount,\n     sourceNetworkId,\n     destinationNetworkId,\n     sourceTokenAddress,\n     destinationTokenAddress,\n    userAddress,\n    feeTokenAddress,\n    slippageTolerance,\n    network_config,\n    widgetId }:\n    { \n         expandedAmount: string,\n         sourceNetworkId: string,\n         destinationNetworkId: string,\n         sourceTokenAddress: string,\n         destinationTokenAddress: string,\n         userAddress:string,\n        feeTokenAddress:string,\n        widgetId:string,\n        slippageTolerance:number,\n        network_config:{ [chainId: string]: NetworkType }\n    }\n) => {\n    let args;\n    if(sourceNetworkId===destinationNetworkId){\n        args={\n            'fromTokenAddress': sourceTokenAddress, // USDC on Polygon\n            'toTokenAddress': destinationTokenAddress, // USDC on Fantom\n            'amount': expandedAmount, // 10 USDC (USDC token contract on Polygon has 6 decimal places)\n            'fromTokenChainId': sourceNetworkId, // Polygon\n            'toTokenChainId': destinationNetworkId, // Fantom\n            'userAddress': userAddress,\n            'feeTokenAddress': feeTokenAddress, // ROUTE on Polygon\n            'slippageTolerance': slippageTolerance,\n            widgetId\n        }\n        // pathUrl = `${PATH_FINDER_ENDPOINT}?fromTokenAddress=${sourceTokenAddress}&toTokenAddress=${destinationTokenAddress}&amount=${expandedAmount}&fromTokenChainId=${sourceNetworkId}&toTokenChainId=${destinationNetworkId}`\n    } else {\n        if(isAddressNative(sourceTokenAddress,sourceNetworkId)||isAddressNative(destinationTokenAddress,destinationNetworkId)){\n            // pathUrl = `${PATH_FINDER_ENDPOINT}?fromTokenAddress=${network_config[sourceNetworkId].wnative}&toTokenAddress=${destinationTokenAddress}&amount=${expandedAmount}&fromTokenChainId=${sourceNetworkId}&toTokenChainId=${destinationNetworkId}`\n            args={\n                'fromTokenAddress': network_config[sourceNetworkId].wnative, // USDC on Polygon\n                'toTokenAddress': network_config[destinationNetworkId].wnative, // USDC on Fantom\n                'amount': expandedAmount, // 10 USDC (USDC token contract on Polygon has 6 decimal places)\n                'fromTokenChainId': sourceNetworkId, // Polygon\n                'toTokenChainId': destinationNetworkId, // Fantom\n                'userAddress': userAddress,\n                'feeTokenAddress': feeTokenAddress, // ROUTE on Polygon\n                'slippageTolerance': slippageTolerance,\n                widgetId\n            }\n        }else if(isAddressNative(sourceTokenAddress,sourceNetworkId)){\n            // pathUrl = `${PATH_FINDER_ENDPOINT}?fromTokenAddress=${network_config[sourceNetworkId].wnative}&toTokenAddress=${destinationTokenAddress}&amount=${expandedAmount}&fromTokenChainId=${sourceNetworkId}&toTokenChainId=${destinationNetworkId}`\n            args={\n                'fromTokenAddress': network_config[sourceNetworkId].wnative, // USDC on Polygon\n                'toTokenAddress': destinationTokenAddress, // USDC on Fantom\n                'amount': expandedAmount, // 10 USDC (USDC token contract on Polygon has 6 decimal places)\n                'fromTokenChainId': sourceNetworkId, // Polygon\n                'toTokenChainId': destinationNetworkId, // Fantom\n                'userAddress': userAddress,\n                'feeTokenAddress': feeTokenAddress, // ROUTE on Polygon\n                'slippageTolerance': slippageTolerance,\n                widgetId\n            }\n        }else if(isAddressNative(destinationTokenAddress,destinationNetworkId)){\n            // pathUrl = `${PATH_FINDER_ENDPOINT}?fromTokenAddress=${sourceTokenAddress}&toTokenAddress=${network_config[destinationNetworkId].wnative}&amount=${expandedAmount}&fromTokenChainId=${sourceNetworkId}&toTokenChainId=${destinationNetworkId}`\n            args={\n                'fromTokenAddress': sourceTokenAddress, // USDC on Polygon\n                'toTokenAddress': network_config[destinationNetworkId].wnative, // USDC on Fantom\n                'amount': expandedAmount, // 10 USDC (USDC token contract on Polygon has 6 decimal places)\n                'fromTokenChainId': sourceNetworkId, // Polygon\n                'toTokenChainId': destinationNetworkId, // Fantom\n                'userAddress': userAddress,\n                'feeTokenAddress': feeTokenAddress, // ROUTE on Polygon\n                'slippageTolerance': slippageTolerance,\n                widgetId\n            }\n        } else{\n            // pathUrl = `${PATH_FINDER_ENDPOINT}?fromTokenAddress=${sourceTokenAddress}&toTokenAddress=${destinationTokenAddress}&amount=${expandedAmount}&fromTokenChainId=${sourceNetworkId}&toTokenChainId=${destinationNetworkId}`\n            args={\n                'fromTokenAddress': sourceTokenAddress, // USDC on Polygon\n                'toTokenAddress': destinationTokenAddress, // USDC on Fantom\n                'amount': expandedAmount, // 10 USDC (USDC token contract on Polygon has 6 decimal places)\n                'fromTokenChainId': sourceNetworkId, // Polygon\n                'toTokenChainId': destinationNetworkId, // Fantom\n                'userAddress': userAddress,\n                'feeTokenAddress': feeTokenAddress, // ROUTE on Polygon\n                'slippageTolerance': slippageTolerance,\n                widgetId\n            }\n        }\n    }\n\n    try {\n        if(args){\n            const pathfinder_response = await fetchPathfinderData(args)\n            return pathfinder_response;\n        }\n    } catch (e) {\n        return e\n    }\n}\n\nexport default getSwapQuote","import { Interface } from \"@ethersproject/abi\";\nimport {  Provider as ProviderType } from \"@ethersproject/providers\";\nimport { ethers } from \"ethers\";\nimport { NetworkType } from \"..\";\nimport erc20Token from \"../abis/ERC20.json\"\n\n\nexport const getSourceTokenApproval = async ({\n    tokenAddress,\n    sourceNetworkId,\n    destinationNetworkId,\n    userAddress,\n    provider,\n    network_config\n    // spenderAddress, // Cross chain reserve handler / same chain one-split\n}: {\n    tokenAddress: string,\n    sourceNetworkId: string,\n    destinationNetworkId: string,\n    userAddress: string,\n    provider:ProviderType,\n    network_config:{ [chainId: string]: NetworkType }\n    // spenderAddress: string\n}) => {\n    try {\n        let spenderAddress;\n        if(sourceNetworkId===destinationNetworkId){\n            spenderAddress=network_config[sourceNetworkId].oneSplit;\n        } else {\n            spenderAddress=network_config[sourceNetworkId].reserveHandler;\n        }\n\n        const erc20Instance = new ethers.Contract(\n            tokenAddress,\n            erc20Token,\n            provider\n        );\n        const result = await erc20Instance.allowance(\n            userAddress,\n            spenderAddress\n        );\n        return result;\n    } catch (error) {\n        console.log(\"Error\", error);\n    }\n}\n\nexport const getFeeTokenApproval = async ({\n    tokenAddress,\n    networkId,\n    userAddress,\n    provider,\n    network_config\n}: {\n    tokenAddress: string,\n    networkId: string\n    userAddress: string,\n    provider: ProviderType,\n    network_config:{ [chainId: string]: NetworkType }\n}) => {\n    try {\n        const spenderAddress=network_config[networkId].reserveHandler;\n        const erc20Instance = new ethers.Contract(\n            tokenAddress,\n            erc20Token,\n            provider\n        );\n        const result = await erc20Instance.allowance(\n            userAddress,\n            spenderAddress\n        );\n        return result;\n    } catch (error) {\n        console.log(\"Error\", error);\n    }\n}\n\nexport const setSourceTokenApproval = async ({\n    tokenAddress,\n    userAddress,\n    amount,\n    sourceNetworkId,\n    destinationNetworkId,\n    network_config\n}: {\n    tokenAddress: string\n    userAddress: string\n    amount: string\n    sourceNetworkId: string,\n    destinationNetworkId: string,\n    network_config:{ [chainId: string]: NetworkType }\n}) => {\n    let spenderAddress;\n        if(sourceNetworkId===destinationNetworkId){\n            spenderAddress=network_config[sourceNetworkId].oneSplit;\n        } else {\n            spenderAddress=network_config[sourceNetworkId].reserveHandler;\n        }\n    try {\n        const iface = new Interface(erc20Token);\n        const rawData= iface.encodeFunctionData(\"approve\",[\n            spenderAddress,\n            amount\n        ])\n        return {\n           to:tokenAddress,\n           from:userAddress,\n           data:rawData,\n        };\n    } catch (error) {\n        console.log(\"Error\", error);\n        return undefined\n    }\n}\n\nexport const setFeeTokenApproval = async ({\n    amount,\n    tokenAddress,\n    userAddress,\n    sourceNetworkId,\n    network_config\n}: {\n    amount: string,\n    tokenAddress: string\n    userAddress: string\n    sourceNetworkId: string,\n    network_config:{ [chainId: string]: NetworkType }\n}) => {\n    const spenderAddress=network_config[sourceNetworkId].reserveHandler;\n    try {\n        const iface = new Interface(erc20Token);\n        const rawData= iface.encodeFunctionData(\"approve\",[\n            spenderAddress,\n            amount\n        ])\n        return {\n            to:tokenAddress,\n            from:userAddress,\n            data:rawData,\n         };\n        \n        } catch (error) {\n        console.log(\"Error\", error);\n        return undefined\n    }\n}","import { Provider as ProviderType } from \"@ethersproject/providers\";\nimport { ethers } from \"ethers\";\nimport { Contract, Provider } from \"ethers-multicall\";\nimport feeHandlerabi from \"../abis/Fee-Manager.json\"\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { NetworkType } from \"..\";\n\nconst getFeeFromFeeHandlerMulticaller = ({ feeHandlerAddress, dstChainID, feeTokenAddress }: {\n  feeHandlerAddress: string, dstChainID: string, feeTokenAddress: string\n}) => {\n\n  const feeHandlerInstance = new Contract(\n    feeHandlerAddress,  \n    feeHandlerabi\n  );\n\n  return feeHandlerInstance.getFeeSafe(dstChainID, feeTokenAddress);\n\n};\n\nconst getFeeTokens = async ({ feeHandlerAddress,\n  provider,\n  dstChainID }: { feeHandlerAddress: string; provider: ProviderType; dstChainID: string }) => {\n  const feeHandlerInstance = new ethers.Contract(\n    feeHandlerAddress,\n    feeHandlerabi,\n    provider\n  );\n\n  try {\n    const tokens = await feeHandlerInstance.getChainFeeTokens(dstChainID);\n    return tokens;\n  } catch (e) {\n    console.log(\"Fee handler error - \", e);\n  }\n};\n//return (fees._transferFee, fees._exchangeFee, fees.accepted);\nexport const getFeeAmount = async ({  sourceProvider, sourceNetworkId,destNetworkId,network_config }: { sourceProvider: ProviderType, sourceNetworkId: string,destNetworkId: string,network_config:{ [chainId: string]: NetworkType }\n}) => {\n  const ethcallProvider = new Provider(sourceProvider, Number(sourceNetworkId))\n  const sourceFeeHandlerAddress=network_config[sourceNetworkId].feeHandler;\n  const destChainId=network_config[destNetworkId].id;\n\n\n  const feeTokenList = await getFeeTokens({\n    feeHandlerAddress: sourceFeeHandlerAddress,\n    provider: sourceProvider,\n    dstChainID: destChainId\n  })\n\n  const contractCalls = feeTokenList.map((feeTokenAddress: string) => getFeeFromFeeHandlerMulticaller({\n    feeHandlerAddress: sourceFeeHandlerAddress,\n    dstChainID: destChainId,\n    feeTokenAddress: feeTokenAddress\n  }))\n\n  const feeArray = await ethcallProvider.all(contractCalls)\n\n  const newFeeTokenList: {\n    address: string;\n    transferFee: BigNumber;\n    exchangeFee: BigNumber;\n  }[] = []\n\n  feeTokenList.forEach((feeTokenAddress: string, index: number) => {\n    if (feeArray[index][2]) {\n      const feeObject = {\n        address: feeTokenAddress,\n        transferFee: feeArray[index][0],\n        exchangeFee: feeArray[index][1],\n      }\n      newFeeTokenList.push(feeObject)\n    }\n  })\n\n  return newFeeTokenList\n} ","import axios from \"axios\"\nimport { ROUTER_STATS_HOST, TransactionStatus } from \"..\"\n\nexport const getTxStatus = async (txHash:string,networkId:string\n    ):Promise<TransactionStatus|undefined>=>{\n    const params={\n        txHash,\n        networkId\n    }\n    const pathUrl = `${ROUTER_STATS_HOST}/api/status`\n    try {\n        const res= await axios.get(pathUrl, { params })\n        return res.data\n    } catch (e) {\n        console.error(`Fetching Transaction Status: ${e}`)\n        return undefined\n    }\n}"],"names":["NETWORK_CONFIG","network_config","networks","forEach","network","networkId","config_generator","ChainId","ASSET_LIST","KOVAN","MUMBAI","BSC","AVALANCHE","FUJI","MAINNET","POLYGON","FANTOM","ARBITRUM","OPTIMISM","ROPSTEN","OKEX","NETWORK_CONFIG_URL","isAddressNative","address","chainId","native","constructor","apiKey","sourceNetworkId","provider","axios","get","then","res","data","networkConfig","err","amount","destinationNetworkId","sourceTokenAddress","destinationTokenAddress","userAddress","feeTokenAddress","slippageTolerance","this","async","expandedAmount","widgetId","args","wnative","params","e","console","error","fetchPathfinderData","getSwapQuote","quote","signer","txGasLimit","gasPrice","getGasPrice","gasLimit","ethers","utils","hexlify","Number","transaction","sendTransaction","txn","execution","wait","tokenAddress","spenderAddress","oneSplit","reserveHandler","erc20Instance","Contract","erc20Token","allowance","log","getSourceTokenApproval","getFeeTokenApproval","transactionReq","to","from","Interface","encodeFunctionData","setSourceTokenApproval","setFeeTokenApproval","sourceProvider","destNetworkId","ethcallProvider","Provider","sourceFeeHandlerAddress","feeHandler","destChainId","id","feeTokenList","feeHandlerAddress","dstChainID","feeHandlerInstance","feeHandlerabi","getChainFeeTokens","getFeeTokens","contractCalls","map","getFeeSafe","getFeeFromFeeHandlerMulticaller","feeArray","all","newFeeTokenList","index","push","transferFee","exchangeFee","getFeeAmount","txHash","getTxStatus"],"mappings":"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"}